import java.util.*
import java.util.Timer

/*
Принцип подстановки Барбары Лисков - это расширенный принцип открытости-закрытости.
Суть принципа в том, что любой программный объект можно заменить его наследником с условием, что его поведение
для внешнего клиента не должно меняться, другими словами логика внутри может меняться и расширяться - однако
контракты взаимодействия с внешними объектами должны оставаться прежними
 */

/*
Для примера у меня есть монитор к которому я подключаю через разьем HDMI игровую консоль с игрой и получаю на выходе
условно видеострим своего игрового процесса.
К монитору можно подключать много разных игровых консолей, которые по разному устроены, но для внешнего клиента
их поведение унифицировано, ты подключаешь консоль через HDMI к монитору, вставляешь диск с игрой и получаешь
видеоизображение своей игры.

 */
// условно класс для инстанса видеоигры, чтобы вызвать функцию игровой консоли
data class Game (val title:String)
// условно видео стрим с игрой
class Stream()
// Абстрактный класс представляющий игровую консоль
abstract class Console{
    abstract fun playGame(game:Game):Stream
}
// Открытый класс представяляющий консоль PS4 являющийся наследником класса Console
open class PS4:Console(){
    override fun playGame(game:Game):Stream {
        println("Playing ${game.title} on PS4")
        return Stream()
    }
}
// Финальный класс PS4Pro являющийся наследником класса PS4
class PS4Pro:PS4(){
    override fun playGame(game:Game):Stream {
        println("Playing ${game.title} on PS4 PRO")
        return Stream()
    }
}
/* Теперь я могу передать в функцию switchToHDMI монитора как класс PS4, так и PS4Pro потому что они прямой и
косвенный наследники класса Console соотвественно, при этом программа будет работать корректно, потому внешнее
ожидаемое поведение заменяемых классов не изменилось
 */
class Monitor{
    fun switchToHDMI(console:Console, game:Game):Stream{
        return console.playGame(game)
    }
}