/*
S- single responsibility principle (принцип единственной отвественности)
Не должно быть более одной причины для изменения класса, под причиной в целом понимается необходимость изменения только
одной базовой функции, которую выполняет класс. Суть в том, что при проектировании решения классы дробить так, чтобы каждый выполнял
свою основную функцию, это позволит гибко реконфигугировать общую архитектуру, избежать излишних зависимостей в жирных
классах*/

/*
В примере ниже главной отвественностью машины является поездка, т.е. причиной изменения класса Car может быть
только изменение логики функции drive(), однако в данной реализации причиной изменени класса может быть также
изменения логики работы двигателя (по умолчанию бензиновый, а может быть электрический) и/или изменение логики работы
 трансмиссии (по умолчанию механика, а может быть автомат).
 */

/*
class Car() {
    init {
        println("Car is created")
    }
    fun drive() {
        if (startEngine()&&getIntoGear())
            println("The car drives into a sunset")
    }

    private fun startEngine(): Boolean {
        class Engine() {
            fun start(): Boolean {
                println("Engine started")
                return true

            }
        }
        return Engine().start()
    }

    private fun getIntoGear():Boolean {
        class Transmission() {
            fun getIntoGear():Boolean {
                println("Got into 1 st gear")
                return true
            }
        }
        return Transmission().getIntoGear()
    }
}

*/

// Выносим класс Engine из тела класса Car и делаем его электрическим
class Engine() {
    fun start(): Boolean {
        println("Engine turned on")
        return true

    }
}

// Выносим класс Transmission из тела класса Car и делаем ее автоматической
class Transmission() {
    fun getIntoGear(): Boolean {
        println("Got into drive position")
        return true
    }
}

class Car() {
    init {
        println("Car is created")
    }

    fun drive() {
        if (startEngine() && getIntoGear())
            println("The car drives into a sunset")
    }

    private fun startEngine(): Boolean {
        return Engine().start()
    }

    private fun getIntoGear(): Boolean {

        return Transmission().getIntoGear()
    }
}

/*
Суть исполнения принципа в этом примере в том, что если изменится какая-то логика работы двигателя или коробки передач
мне не нужно для этого править класс Car, мне нужно поправить классы Engine и Transmission.
Если для выполнения основной функции класса Car понадобиться что-то еще, например, чтобы поехать  обязательно нужно
пристегнуться, я создам новый класс SeatBelts c функцией fasten(), добавлю функцию для пристегивания ремня в
класс Car и внесу изменения в условия в функции drive()
 */


/* O open-closed principle (принципы открытости-закрытости)
"Принцип открытости/закрытости - открытость для изменений внешнего поведения класса, метода, интерфейса и пр. за счет
механизмов расширения (наследования) и переопределении функций и пропертей, при закрытости для внесения изменений в сам
родительский класс
L - LSP (принцип подстановки Барбары Лисков)
Любой объект программы можно заменить его наследником без внесения изменений в контракты внешнего поведения класса (
Здесь акцент на рост функциональности через расширение, но с сохранением контрактов внешнего поведения базовых классов) "
I - ISP (Принцип разделения интерфейсов)
Клиент (класс) не должен быть вынужден реализовывать методы, которые ему не нужны при имплементации общих интерфейсов.
Суть принципа в том, чтобы не создавать жирные интерфейсы и стараться максимально дробить специфичные функции на специфичные
интерфейсы, чтобы при имплементации реализовывать только необходимые функции
D - DIP (принцип обратной зависимости)
Модули высшего порядка не должны зависить от конкретной реализации модулей низшего порядка, модули высшего порядка
должны использовать абстракции (в данном случае подразумеваются интерфейсы) для работы с модулями низшего порядка.
Например, чтобы создать кофе, нужно помолоть зерна и сварить кофе, можно создать ручную или авто кофемолку, а также создать
капельную кофеварку или турку, и вызвать метод получить кофе класса кофе и передать туда объекты кофемолка и кофеварка,
Тогда класс кофе будет зависеть от конкретных классов кофемолок и кофеварок, и придется создавать методы получения кофе
с каждой реализацией кофпмолоки корфеварок - это бред. Можно создать интерфейсы для всех кофемолок и кофеварок, в функцию
получения кофе класса кофе передавать эти интерфейсы как параметры, и все конкретные реализации кофемолок и кофеварок
создавать имплементируя интерфейсы, и тогда я смогу создать одну функцию получения кофе, которая сможет принимать на
входе множество разных реализаций кофемолок и кофеварок, лишь бы они имплементировали контракты в интерфейсах
 */